/*	File:		glut_overlay.c	Contains:		Written by:	Mark J. Kilgard	Mac OS by:	John Stauffer and Geoff Stahl	Copyright:	Copyright © Mark J. Kilgard, 1996.					MacOS portions Copyright © Apple Computer, Inc., 1999	Change History (most recent first):        <3+>     8/31/99    ggs              <3>     7/16/99    ggs     Fixed attributions and copyrights         <2>     5/31/99    ggs     remove extranious includes         <1>     5/23/99    GGS     OpenGL glut original source*//* Copyright © Mark J. Kilgard, 1996.  *//* This program is freely distributable without licensing feesand is provided without guarantee or warrantee expressed orimplied. This program is -not- in the public domain. *//*Overlays are currently not supported in the Macintosh version of GLUT*/#include <stdlib.h>#include <stdio.h>#include <string.h>#include <assert.h>#include "glutint.h"void glutEstablishOverlay(void){}void glutRemoveOverlay(void){}void glutUseLayer(GLenum layer){}void glutPostOverlayRedisplay(void){/*	if(!__glutCurrentWindow)	{		__glutWarning("glutPostOverlayRedisplay: no active window");		return;	}		__glutPutOnWorkList(__glutCurrentWindow, GLUT_OVERLAY_REDISPLAY_WORK);*/}/* The advantage of this routine is that it saves the cost of a   glutSetWindow call (entailing an expensive OpenGL context   switch), particularly useful when multiple windows need   redisplays posted at the same times. */void glutPostWindowOverlayRedisplay(int win){//  __glutPutOnWorkList(__glutWindowList[win - 1], GLUT_OVERLAY_REDISPLAY_WORK);}void glutOverlayDisplayFunc(GLUTdisplayCB displayFunc){}void glutHideOverlay(void){}void glutShowOverlay(void){}int glutLayerGet(GLenum param){  switch (param) {  case GLUT_OVERLAY_POSSIBLE:    {      return -1;    }  case GLUT_LAYER_IN_USE:    return __glutCurrentWindow->renderWin != __glutCurrentWindow->win;  case GLUT_HAS_OVERLAY:    return __glutCurrentWindow->overlay != NULL;  case GLUT_TRANSPARENT_INDEX:    if (__glutCurrentWindow->overlay) {      return __glutCurrentWindow->overlay->transparentPixel;    } else {      return -1;    }  case GLUT_NORMAL_DAMAGED:    /* __glutWindowDamaged is used so the damage state within       the window (or overlay belwo) can be cleared before       calling a display callback so on return, the state does       not have to be cleared (since upon return from the       callback the window could be destroyed (or layer       removed). */    return (__glutCurrentWindow->workMask & GLUT_REPAIR_WORK)      || __glutWindowDamaged;  case GLUT_OVERLAY_DAMAGED:    if (__glutCurrentWindow->overlay) {      return (__glutCurrentWindow->workMask & GLUT_OVERLAY_REPAIR_WORK)        || __glutWindowDamaged;    } else {      return -1;    }  default:    __glutWarning("invalid glutLayerGet param: %d", param);    return -1;  }}