/*	File:		glut_win.c	Contains:		Written by:	Mark J. Kilgard	Mac OS by:	John Stauffer and Geoff Stahl	Copyright:	Copyright © Mark J. Kilgard, 1994.				MacOS portions Copyright © Apple Computer, Inc., 1999	Change History (most recent first):       <14+>    10/17/99    ggs             <14>    10/13/99    ggs             <13>     8/28/99    ggs     From js: Fixed Headers, fixed error labels, removed out                                    condition for setting of current window, removed explict setting                                    of fullscreen to false if not gamemode        <12>     7/16/99    ggs     short circuited __glutSetCurrentWindow for self setting and null                                    windows        <11>     7/16/99    ggs     added go away box to window        <10>     7/16/99    ggs     Fixed attributions and copyrights         <9>     7/16/99    ggs     Removed fullscreen switches since fullscreen windows are really                                    windows on top of the blanking window         <8>     6/22/99    ggs     Corrected back ground window blanking         <7>     6/22/99    ggs     Cleaned up windowcreation and background clearing, add reset of                                    fore and back colors before  swap (still have problem with                                    balckscreen on powerbook G3)         <6>     5/31/99    ggs     fixed header; chnaged menus to menu and removed superfluous                                    includes         <5>     5/28/99    GGS     Cleaned up various full screen handling problems         <4>     5/24/99    GGS     Added gamemode support         <3>     5/24/99    GGS     Change GetNewCWindow to NewCWindow, could not find the resource                                    that it was supposed to reference; added reference to gamemode         <2>     5/23/99    GGS     3.7 glint/glut header compliance, added gamemode (stubs only)         <1>     5/23/99    GGS     OpenGL glut original source*//* Copyright © Mark J. Kilgard, 1994. *//* This program is freely distributable without licensing fees    and is provided without guarantee or warrantee expressed or    implied. This program is -not- in the public domain. */#include <stdlib.h>#include <stdio.h>#include <string.h>#include <assert.h>#include "gl.h"#include "agl.h"#include "glut.h"#include "glutint.h"// included from "win32_x11.h"#define NoEventMask			0L#define KeyPressMask			(1L<<0)  #define KeyReleaseMask			(1L<<1)  #define ButtonPressMask			(1L<<2)  #define ButtonReleaseMask		(1L<<3)  #define EnterWindowMask			(1L<<4)  #define LeaveWindowMask			(1L<<5)  #define PointerMotionMask		(1L<<6)  #define PointerMotionHintMask		(1L<<7)  #define Button1MotionMask		(1L<<8)  #define Button2MotionMask		(1L<<9)  #define Button3MotionMask		(1L<<10) #define Button4MotionMask		(1L<<11) #define Button5MotionMask		(1L<<12) #define ButtonMotionMask		(1L<<13) #define KeymapStateMask			(1L<<14)#define ExposureMask			(1L<<15) #define VisibilityChangeMask		(1L<<16) #define StructureNotifyMask		(1L<<17) #define ResizeRedirectMask		(1L<<18) #define SubstructureNotifyMask		(1L<<19) #define SubstructureRedirectMask	(1L<<20) #define FocusChangeMask			(1L<<21) #define PropertyChangeMask		(1L<<22) #define ColormapChangeMask		(1L<<23) #define OwnerGrabButtonMask		(1L<<24) GLUTwindow *__glutCurrentWindow = NULL;GLUTwindow **__glutWindowList = NULL;int __glutWindowListSize = 0;static GLUTwindow *__glutWindowCache = NULL;GLUTwindow * __glutGetWindow(CWindowPtr win){	int i;	/* Does win belong to the last window ID looked up? */	if(__glutWindowCache && (win == __glutWindowCache->win))	{		return __glutWindowCache;	}		/* Otherwise scan the window list looking for the window ID. */	for(i = 0; i < __glutWindowListSize; i++)	{		if(__glutWindowList[i])		{			if(win == __glutWindowList[i]->win)			{				__glutWindowCache = __glutWindowList[i];				return __glutWindowCache;			}		}	}	return NULL;}int glutGetWindow(void){	if(__glutCurrentWindow)		return __glutCurrentWindow->num + 1;	else		return 0;}int __glutSetCurrentWindow(GLUTwindow *window){//	if (window && (__glutCurrentWindow != window))		{		__glutCurrentWindow = window;		if(__glutCurrentWindow)		{			#if TARGET_API_MAC_CARBON == 0				aglSetDrawable(__glutCurrentWindow->ctx, GetWindowPort((GrafPort *) __glutCurrentWindow->win));			#else				aglSetDrawable(__glutCurrentWindow->ctx, GetWindowPort(__glutCurrentWindow->win));			#endif						aglSetCurrentContext(__glutCurrentWindow->ctx);		}		else		{			AGLContext ctx = aglGetCurrentContext();						if(ctx)			{				aglSetCurrentContext(NULL);				aglSetDrawable(ctx, NULL);			}		}	}	return (__glutCurrentWindow ? true : false);}void glutSetWindow(int win){	GLUTwindow *window;	if(win < 1 || win > __glutWindowListSize)	{		__glutWarning("glutSetWindow attempted on bogus window.");		return;	}	window = __glutWindowList[win - 1];	if(!window)	{		__glutWarning("glutSetWindow attempted on invalid window.");		return;	}	__glutSetCurrentWindow(window);}static int getUnusedWindowSlot(void){	int i;	/* Look for allocated, unused slot. */	for(i = 0; i < __glutWindowListSize; i++)	{		if(!__glutWindowList[i])		{			return i;		}	}		/* Allocate a new slot. */	__glutWindowListSize++;		if(__glutWindowList)	{		__glutWindowList = (GLUTwindow **) realloc(__glutWindowList,						__glutWindowListSize * sizeof(GLUTwindow *));	}	else	{		__glutWindowList = (GLUTwindow **) malloc(sizeof(GLUTwindow *));	}		if(!__glutWindowList) __glutFatalError("out of memory.");		__glutWindowList[__glutWindowListSize - 1] = NULL;		return __glutWindowListSize - 1;}static AGLPixelFormat getVisualInfoCI(unsigned int mode){	static GLint bufSizeList[] = { 16, 12, 8, 4, 2, 1, 0 };	AGLPixelFormat vi = NULL;	GLint list[32];	GLint i, n = 0;	list[n++] = AGL_BUFFER_SIZE;	list[n++] = 1;		if (GLUT_WIND_IS_DOUBLE(mode))	{		list[n++] = AGL_DOUBLEBUFFER;	}		if (GLUT_WIND_IS_STEREO(mode))	{		list[n++] = AGL_STEREO;	}		if (GLUT_WIND_HAS_DEPTH(mode))	{		list[n++] = AGL_DEPTH_SIZE;		list[n++] = 1;	}		if (GLUT_WIND_HAS_STENCIL(mode))	{		list[n++] = AGL_STENCIL_SIZE;		list[n++] = 1;	}	//	if(GLUT_WIND_IS_FULLSCREEN(mode))//	{//		list[n++] = AGL_FULLSCREEN;//	}		list[n] = AGL_NONE;	aglConfigure(AGL_RETAIN_RENDERERS, GL_TRUE);	/* beretta */	for(i = 0; bufSizeList[i]; i++)	{		list[1] = bufSizeList[i];		vi = aglChoosePixelFormat(NULL, 0, list);	}	aglConfigure(AGL_RETAIN_RENDERERS, GL_FALSE);	/* beretta */		return vi;}static AGLPixelFormat getVisualInfoRGB(unsigned int mode){	GLint list[40];	GLint n = 0;	list[n++] = AGL_RGBA;	/*	list[n++] = AGL_RED_SIZE;	list[n++] = 1;	list[n++] = AGL_GREEN_SIZE;	list[n++] = 1;	list[n++] = AGL_BLUE_SIZE;	list[n++] = 1;*/	if(GLUT_WIND_HAS_ALPHA(mode))	{		list[n++] = AGL_ALPHA_SIZE;		list[n++] = 1;	}		if(GLUT_WIND_IS_DOUBLE(mode))	{		list[n++] = AGL_DOUBLEBUFFER;	}		if(GLUT_WIND_IS_STEREO(mode))	{		list[n++] = AGL_STEREO;	}		if(GLUT_WIND_HAS_DEPTH(mode))	{		list[n++] = AGL_DEPTH_SIZE;		list[n++] = 24;	}		if(GLUT_WIND_HAS_STENCIL(mode))	{		list[n++] = AGL_STENCIL_SIZE;		list[n++] = 1;	}		if(GLUT_WIND_HAS_ACCUM(mode))	{		list[n++] = AGL_ACCUM_RED_SIZE;		list[n++] = 16;		list[n++] = AGL_ACCUM_GREEN_SIZE;		list[n++] = 16;		list[n++] = AGL_ACCUM_BLUE_SIZE;		list[n++] = 16;				if(GLUT_WIND_HAS_ALPHA(mode))		{			list[n++] = AGL_ACCUM_ALPHA_SIZE;			list[n++] = 16;		}	}	//	if(GLUT_WIND_IS_FULLSCREEN(mode))//	{//		list[n++] = AGL_FULLSCREEN;//	}		list[n++] = AGL_ALL_RENDERERS;		#if defined(AGL_VERSION_1_1) && defined(AGL_SGIS_multisample)		if(GLUT_WIND_IS_MULTISAMPLE(mode))		{			if(!__glutIsSupportedByAGL("AGL_SGIS_multisample"))				return NULL;			list[n++] = AGL_SAMPLES_SGIS;			list[n++] = 4;		}	#endif		list[n] = (int) AGL_NONE; /* terminate list */	return aglChoosePixelFormat(NULL, 0, list);}AGLPixelFormat __glutGetVisualInfo(unsigned int mode){	if (GLUT_WIND_IS_LUMINANCE(mode)) return NULL;	if (GLUT_WIND_IS_RGB(mode))		return getVisualInfoRGB(mode);	else		return getVisualInfoCI(mode);}AGLPixelFormat __glutDetermineVisual(unsigned int displayMode, Bool *treatAsSingle,  									AGLPixelFormat (getVisualInfo) (unsigned int)){	AGLPixelFormat vis;	*treatAsSingle = GLUT_WIND_IS_SINGLE(displayMode);	vis = getVisualInfo(displayMode);		if (!vis)	{		if(GLUT_WIND_IS_SINGLE(displayMode))		{			displayMode |= GLUT_DOUBLE;			vis = getVisualInfo(displayMode);			*treatAsSingle = true;		}				if (!vis && GLUT_WIND_IS_MULTISAMPLE(displayMode))		{			displayMode &= ~GLUT_MULTISAMPLE;			vis = getVisualInfo(displayMode);		}	}		return vis;}static AGLPixelFormat __glutDetermineWindowVisual(Bool *treatAsSingle){	if(__glutDisplayString)	{		return __glutVisualInfoFromString(__glutDisplayString);	}	else	{		return __glutDetermineVisual(__glutDisplayMode, treatAsSingle, __glutGetVisualInfo);	}}void __glutSetupColormap(AGLPixelFormat vi, GLUTcolormap ** colormap, CSpecArray * cmap){}void __glutDefaultDisplay(void){	__glutWarning("The following is a new check for GLUT 3.0; update your code.");		if(__glutCurrentWindow)		__glutFatalError( "redisplay needed for window %d, but no display callback.", __glutCurrentWindow->num + 1);	else		__glutFatalError( "redisplay needed for window ?, but no display callback.");}void __glutDefaultReshape(int width, int height){}GLUTwindow *__glutCreateWindow(GLUTwindow *parent, const char *title, int x, int y, int width, int height, int win_type){	Rect rectBounds; 	Point pntParentLoc = {0, 0};	Str255 ps;	GLUTwindow *window;	GLint value;	int winnum;	int i, arc = 0;	RGBColor rgbSave;	GrafPtr pGrafSave;		__glutInit();	winnum = getUnusedWindowSlot();		window = (GLUTwindow *) malloc(sizeof(GLUTwindow));	if(!window)	{		__glutFatalError("out of memory.");	}		window->num = winnum;	window->vis = __glutDetermineWindowVisual(&window->treatAsSingle);	if(!window->vis)	{		__glutFatalError("visual with necessary capabilities not found.");	}		window->ctx = aglCreateContext(window->vis, NULL);	if(!window->ctx)	{		__glutFatalError("context could not be created.");	}		window->renderCtx = window->ctx;	//	aglDescribePixelFormat(window->vis, AGL_FULLSCREEN, &value);	if (win_type == kGameMode)		window->fullscreen = true;	else		window->fullscreen = false;		aglDescribePixelFormat(window->vis, AGL_RGBA, &value);	if(!value) aglDisable(window->ctx, AGL_COLORMAP_TRACKING);    if (win_type == kGameMode) 		win_type = plainDBox;//	if(!window->fullscreen)	{		// 5/24/99 GGS: removed (do not have a resource to access)//		window->win = (CWindowPtr) GetNewCWindow(win_type,nil,(WindowPtr)-1L);		if (parent)		{			GetPort(&pGrafSave);#if TARGET_API_MAC_CARBON			SetPortWindowPort(parent->win);#else			SetPort((GrafPtr) parent->win);#endif#if TARGET_API_MAC_CARBON{			Rect window_bounds_rect;						GetWindowPortBounds(parent->win, &window_bounds_rect);						pntParentLoc.h = window_bounds_rect.left;			pntParentLoc.v = window_bounds_rect.top;}#else					pntParentLoc.h = parent->win->portRect.left;			pntParentLoc.v = parent->win->portRect.top;#endif			LocalToGlobal (&pntParentLoc);			SetPort (pGrafSave);		}		SetRect (&rectBounds, x + pntParentLoc.h, y + pntParentLoc.v, x + width + pntParentLoc.h, y + height + pntParentLoc.v);#if TARGET_API_MAC_CARBON		window->win = NewCWindow (nil, &rectBounds, "\pGLUT Window", false, win_type, (WindowPtr)-1L, GL_TRUE, winnum);		#else		window->win = (CWindowPtr) NewCWindow (nil, &rectBounds, "\pGLUT Window", false, win_type, (WindowPtr)-1L, GL_TRUE, winnum);		#endif		if(!window->win)		{			__glutFatalError("window could not be created.");		}				if(title)		{			strcpy(window->title, title);			__glutCToStr255(window->title, ps);#if TARGET_API_MAC_CARBON			SetWTitle(window->win, ps);#else			SetWTitle((GrafPort *) window->win, ps);#endif		}		else		{			strcpy(window->title, "GLUT Window");		}//		MoveWindow((GrafPort *) window->win, x, y, GL_FALSE);//		SizeWindow((GrafPort *) window->win, width, height,GL_FALSE);	// paint back ground black before fade in to avoid white background flash		GetPort (&pGrafSave);#if TARGET_API_MAC_CARBON		SetPortWindowPort(window->win);#else		SetPort ((GrafPtr)window->win);#endif		GetForeColor (&rgbSave);		RGBForeColor (&rgbBlack);#if TARGET_API_MAC_CARBON{		Rect window_bounds_rect;					GetWindowPortBounds(window->win, &window_bounds_rect);		PaintRect(&window_bounds_rect);				QDFlushPortBuffer(GetWindowPort(window->win), NULL);}#else					PaintRect (&((window->win)->portRect));#endif#if TARGET_API_MAC_CARBON		ShowWindow(window->win);#else		ShowWindow((GrafPort *) window->win);#endif		RGBForeColor (&rgbSave);		// ensure background color is reset for proper blitting		SetPort (pGrafSave);//		HiliteWindow((GrafPort *) window->win, TRUE);//		SetPort((GrafPort *) window->win);	}//	else//	{//		window->win = NULL;//		strcpy(window->title, "");//	}	//tad:	window->visState = -1;	window->renderWin = window->win;		window->width = width;	window->height = height;	window->forceReshape = true;	window->ignoreKeyRepeat = false;	window->button_press = 0;		window->parent = parent;	if(parent)	{		window->siblings = parent->children;		parent->children = window;	}	else	{		window->siblings = NULL;	}	window->children = NULL;	window->prevWorkWin = NULL;	window->display = __glutDefaultDisplay;	window->reshape = __glutDefaultReshape;	window->visibility = NULL;	window->workMask = GLUT_NO_WORK;	window->mouse = NULL;	window->special = NULL;	window->specialUp = NULL;	window->motion = NULL;	window->passive = NULL;	window->keyboard = NULL;	window->keyboardUp = NULL;	window->entry = NULL;	window->menu_state = NULL;	window->menu_status = NULL;	window->window_status = NULL;	window->entry_mode = 0;	window->cursor = GLUT_CURSOR_INHERIT;		for(i = 0; i < GLUT_MAX_MENUS; i++) window->menu[i] = 0;#if TARGET_API_MAC_CARBON	SelectWindow (window->win);	// ensure window is selected#else	SelectWindow ((GrafPtr)window->win);	// ensure window is selected#endif	__glutWindowList[winnum] = window;	__glutSetCurrentWindow(window);			return window;}int glutCreateWindow(const char *title){	int x = __glutInitX, y = __glutInitY;	GLUTwindow *window;	// ggs: ensure we are inited correctly	__glutInit();		if (__glutGameModeWindow) 	{		__glutFatalError("cannot create windows in game mode.");	}	if (0 > x)		x = 50;	if (0 > y)		y = 50;	window = __glutCreateWindow(NULL, title,		x, y,		__glutInitWidth, __glutInitHeight, kMainWindow);	return window->num + 1;}// do we need this function?//int glutCreatePlainWindow(const char *title)//{//	GLUTwindow *window;//	window = __glutCreateWindow(NULL, title,//		__glutInitX, __glutInitY,//		__glutInitWidth, __glutInitHeight, kPlainWindow);//	return window->num + 1;//}int glutCreateSubWindow(int win, int x, int y, int width, int height){  GLUTwindow *window;  if(__glutWindowList[win - 1])  {  	window = __glutCreateWindow(__glutWindowList[win - 1], "GLUT Window",    	x, y, width, height, kPlainWindow);  }  else  {  	window = __glutCreateWindow(__glutWindowList[win - 1], __glutWindowList[win - 1]->title,    	x, y, width, height, kMainWindow);  }  return window->num + 1;}void __glutDestroyWindow(GLUTwindow * window, GLUTwindow * initialWindow){	GLUTwindow **prev, *cur, *parent, *siblings;	if(!window) return;		__glutRemoveFromWorkList(window);	// do we need to do vis changes???		/* Recursively destroy any children. */	cur = window->children;	while(cur)	{		siblings = cur->siblings;		__glutDestroyWindow(cur, initialWindow);		cur = siblings;	}		/* Remove from parent's children list (only necessary for	non-initial windows and subwindows!). */	parent = window->parent;	if(parent && parent == initialWindow->parent)	{		prev = &parent->children;		cur = parent->children;				while(cur)		{			if(cur == window)			{				*prev = cur->siblings;				break;			}						prev = &(cur->siblings);			cur = cur->siblings;		}	}		aglDestroyContext(window->ctx);	/* Unbind if bound to this window. */	if(window == __glutCurrentWindow)		__glutSetCurrentWindow(NULL);	//	if(!window->fullscreen)#if TARGET_API_MAC_CARBON		DisposeWindow(window->win);#else		DisposeWindow((GrafPort *) window->win);#endif	/* NULLing the __glutWindowList helps detect is a window	instance has been destroyed, given a window number. */	__glutWindowList[window->num] = NULL;	/* Remove window from the "get window cache" if it is there. */	if(__glutWindowCache == window)		__glutWindowCache = NULL;	aglDestroyPixelFormat(window->vis);  if (window == __glutGameModeWindow) {    /* Destroying the game mode window should implicitly       have GLUT leave game mode. */    __glutCloseDownGameMode();  }	free(window);		// rescan for vis changes (if invalid report any state)}void glutDestroyWindow(int win){  GLUTwindow *window = __glutWindowList[win - 1];  __glutDestroyWindow(window, window);}void glutSwapBuffers(void){	aglSwapBuffers(aglGetCurrentContext());}void__glutChangeWindowEventMask(long eventMask, Bool add){  if (add) {    /* Add eventMask to window's event mask. */    if ((__glutCurrentWindow->eventMask & eventMask) !=      eventMask) {      __glutCurrentWindow->eventMask |= eventMask;      __glutPutOnWorkList(__glutCurrentWindow,        GLUT_EVENT_MASK_WORK);    }  } else {    /* Remove eventMask from window's event mask. */    if (__glutCurrentWindow->eventMask & eventMask) {      __glutCurrentWindow->eventMask &= ~eventMask;      __glutPutOnWorkList(__glutCurrentWindow,        GLUT_EVENT_MASK_WORK);    }  }}void glutDisplayFunc(GLUTdisplayCB displayFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutDisplayFunc: no active window");		return;	}	if (!displayFunc) __glutFatalError("NULL display callback not allowed in GLUT 3.0; update your code.");	__glutCurrentWindow->display = displayFunc;}void glutKeyboardFunc(GLUTkeyboardCB keyboardFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutKeyboardFunc: no active window");		return;	}	  __glutCurrentWindow->keyboard = keyboardFunc;}void glutSpecialFunc(GLUTspecialCB specialFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutSpecialFunc: no active window");		return;	}	  __glutCurrentWindow->special = specialFunc;}void glutMouseFunc(GLUTmouseCB mouseFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutMouseFunc: no active window");		return;	}	  __glutCurrentWindow->mouse = mouseFunc;}void glutMotionFunc(GLUTmotionCB motionFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutMotionFunc: no active window");		return;	}	  __glutCurrentWindow->motion = motionFunc;    if(motionFunc) __glutPutOnWorkList(__glutCurrentWindow, GLUT_BUTTON_WORK);}void glutPassiveMotionFunc(GLUTpassiveCB passiveMotionFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutPassiveMotionFunc: no active window");		return;	}	  __glutCurrentWindow->passive = passiveMotionFunc;    if(passiveMotionFunc) __glutPutOnWorkList(__glutCurrentWindow, GLUT_PASSIVE_WORK);}void glutEntryFunc(GLUTentryCB entryFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutEntryFunc: no active window");		return;	}		__glutCurrentWindow->entry = entryFunc;	__glutCurrentWindow->entry_mode = GLUT_ENTERED;			if(entryFunc) __glutPutOnWorkList(__glutCurrentWindow, GLUT_ENTRY_WORK);}void glutWindowStatusFunc(GLUTwindowStatusCB windowStatusFunc){  __glutChangeWindowEventMask(VisibilityChangeMask,    windowStatusFunc != NULL);	__glutCurrentWindow->window_status = windowStatusFunc;  if (!windowStatusFunc) {    /* Make state invalid. */    __glutCurrentWindow->visState = -1;  }/*	if(!__glutCurrentWindow)	{		__glutWarning("glutwindow_statusFunc: no active window");		return;	}		__glutCurrentWindow->window_status = window_statusFunc;*/}static voidvisibilityHelper(int status){  if (status == GLUT_HIDDEN || status == GLUT_FULLY_COVERED)    __glutCurrentWindow->visibility(GLUT_NOT_VISIBLE);  else    __glutCurrentWindow->visibility(GLUT_VISIBLE);}void glutVisibilityFunc(GLUTvisibilityCB visibilityFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutVisibilityFunc: no active window");		return;	}		__glutCurrentWindow->visibility = visibilityFunc;  if (visibilityFunc)    glutWindowStatusFunc(visibilityHelper);  else    glutWindowStatusFunc(NULL);//	__glutCurrentWindow->visibility = visibilityFunc;	//	if(visibilityFunc) visibilityFunc(GLUT_VISIBLE);	// don't call initially, only call when vis changes}void glutReshapeFunc(GLUTreshapeCB reshapeFunc){	if(!__glutCurrentWindow)	{		__glutWarning("glutReshapeFunc: no active window");		return;	}	  if(reshapeFunc)  {		__glutCurrentWindow->reshape = reshapeFunc;  }  else  {		__glutCurrentWindow->reshape = __glutDefaultReshape;  }}